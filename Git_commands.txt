1. Setup the name and email that will be attached to your commits and tags:

$ git config --global user.name "Augustas Karpavicius"
$ git config --global user.email "karpavicius@arcnl.nl"

2. Sart a project: create a local repository, to initialise the current directory as a git repo:

$ git init <directory>
$ git clone <url>  # Download a remote repo (i.e. PRA)

3. Add files to staging:

$ git add <file>
$ git add ./ git add --all/ git add -A  # Stage all files

4. Committing:

$ git commit -m "commit message"  # Commit all staged files to git
$ git commit -am "commit message"  # Add all changes made to tracked files and commit (without staging)

5. Reviewing your repository:

$ ls  # list the files in the current directory

$ git status  # List new or modified files not yet committed
$ git status --short  # Show changes in a more compact way: ?? - Untracked, A - Staged, M - Modified, D - deleted

$ git log  # List commit history with respective IDs
$ git log --oneline  # Shorter commit history without committer

$ git diff  # Show changes to unstaged files. For changes to staged files, add --cached option
$ git diff commit1_ID commit2_ID  # Show changes between two commits

$ gitk  # Shows visualisation of different branches

5. Branches:

$ git branch  # List all local branches. Add -r flag to show all remote branches, -a flag to all branches.
$ git branch <new-branch-name>  # Create a new branch
$ git checkout <branch>  # Switch to a branch and update the working directory
$ git checkout -b <new-branch-name>  # Create a new branch and switch to it
$ git branch -d <branch>  # Delete a branch (we would use -D if it doesn't matter whether the branch is merged or not)
$ git tag <tag-name>  # Add a tag to current commit

6. Merging and rebasing

$ git checkout b  # Switch to the branche into which we merge the other branch (i.e. master)
$ git merga a  # Merge branch a into branch b. Add --no-ff option for no-fast-forward merge
$ git merge --squash a  # merge and squash all commits into the new commit